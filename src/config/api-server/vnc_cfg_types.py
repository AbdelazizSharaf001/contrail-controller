#
# Copyright (c) 2013 Juniper Networks, Inc. All rights reserved.
#
#
# This file is built up from an autogenerated template resource_server.py and
# contains code/hooks at different point during processing a request, specific
# to type of resource. For eg. allocation of mac/ip-addr for a port during its
# creation.

import json

import cfgm_common
from gen.resource_xsd import *
from gen.resource_common import *
from gen.resource_server import *

class FloatingIpServer(FloatingIpServerGen):
    generate_default_instance = False

    @classmethod
    def http_post_collection(cls, tenant_name, obj_dict):
        vn_fq_name = obj_dict['fq_name'][:-2]
        req_ip = obj_dict['floating_ip_address'] if 'floating_ip_address' in obj_dict else None
        try:
            fip_addr = cls.addr_mgmt.ip_alloc(vn_fq_name, asked_ip_addr = req_ip)
        except Exception as e:
            return (False, (503, str(e)))
        obj_dict['floating_ip_address'] = fip_addr;
        print 'AddrMgmt: alloc %s FIP for vn=%s, tenant=%s, askip=%s' \
            %(obj_dict['floating_ip_address'], vn_fq_name, tenant_name, req_ip)
        return True, ""
    #end http_post_collection

    @classmethod
    def http_delete(cls, id, obj_dict):
        vn_fq_name = obj_dict['fq_name'][:-2]
        fip_addr = obj_dict['floating_ip_address']
        print 'AddrMgmt: free FIP %s for vn=%s' %(fip_addr, vn_fq_name)
        cls.addr_mgmt.ip_free(fip_addr, vn_fq_name)
        return True, ""
    #end http_delete

#end class FloatingIpServer

class InstanceIpServer(InstanceIpServerGen):
    generate_default_instance = False

    @classmethod
    def http_post_collection(cls, tenant_name, obj_dict):
        vn_fq_name = obj_dict['virtual_network_refs'][0]['to']
        if ((vn_fq_name == cfgm_common.IP_FABRIC_VN_FQ_NAME) or
            (vn_fq_name == cfgm_common.LINK_LOCAL_VN_FQ_NAME)):
            # Ignore ip-fabric and link-local address allocations
            return True,  ""

        req_ip = obj_dict['instance_ip_address'] if 'instance_ip_address' in obj_dict else None
        try:
            ip_addr = cls.addr_mgmt.ip_alloc(vn_fq_name, asked_ip_addr = req_ip)
        except Exception as e:
            return (False, (503, str(e))) 
        obj_dict['instance_ip_address'] = ip_addr
        print 'AddrMgmt: alloc %s for vn=%s, tenant=%s, askip=%s' \
            %(obj_dict['instance_ip_address'], vn_fq_name, tenant_name, req_ip)
        return True, ""
    #end http_post_collection

    @classmethod
    def http_delete(cls, id, obj_dict):
        vn_fq_name = obj_dict['virtual_network_refs'][0]['to']
        if ((vn_fq_name == cfgm_common.IP_FABRIC_VN_FQ_NAME) or
            (vn_fq_name == cfgm_common.LINK_LOCAL_VN_FQ_NAME)):
            # Ignore ip-fabric and link-local address allocations
            return True,  ""

        ip_addr = obj_dict['instance_ip_address']
        print 'AddrMgmt: free IP %s, vn=%s' %(ip_addr, vn_fq_name)
        cls.addr_mgmt.ip_free(ip_addr, vn_fq_name)
        return True, ""
    #end http_delete

#end class InstanceIpServer

class VirtualMachineInterfaceServer(VirtualMachineInterfaceServerGen):
    generate_default_instance = False

    @classmethod
    def http_post_collection(cls, tenant_name, obj_dict):
        mac_addr = cls.addr_mgmt.mac_alloc(obj_dict)
        mac_addrs_obj = MacAddressesType([mac_addr])
        mac_addrs_json = json.dumps(mac_addrs_obj, default=lambda o: dict((k, v) for k, v in o.__dict__.iteritems()))
        mac_addrs_dict = json.loads(mac_addrs_json)
        obj_dict['virtual_machine_interface_mac_addresses'] = mac_addrs_dict
        return True, ""
    #end http_post_collection

#end class VirtualMachineInterfaceServer

class VirtualNetworkServer(VirtualNetworkServerGen):

    @classmethod
    def http_post_collection(cls, tenant_name, obj_dict):
        cls.addr_mgmt.net_create(obj_dict)
        return True, ""
    #end http_post_collection
     
    @classmethod
    def http_put(cls, id, obj_dict):
        if ((obj_dict['fq_name'] == cfgm_common.IP_FABRIC_VN_FQ_NAME) or 
            (obj_dict['fq_name'] == cfgm_common.LINK_LOCAL_VN_FQ_NAME)):
            # Ignore ip-fabric subnet updates
            return True,  ""

        (ok, result) = cls.addr_mgmt.net_check_subnet_overlap(obj_dict)
        if not ok:
            return ok, result
        (ok, result) = cls.addr_mgmt.net_check_subnet_delete(obj_dict)
        if not ok:
            return ok, result
        cls.addr_mgmt.net_create(obj_dict, id)

        return True, ""
    #end http_put

    @classmethod
    def http_delete(cls, id, obj_dict):
        cls.addr_mgmt.net_delete(obj_dict)
        return True, ""
    #end http_delete

    @classmethod
    def ip_alloc(cls, vn_fq_name, subnet_name, count):
        ip_list = [cls.addr_mgmt.ip_alloc(vn_fq_name, subnet_name) for i in range(count)]
        print 'AddrMgmt: reserve %d IP for vn=%s, subnet=%s - %s' \
            %(count, vn_fq_name, subnet_name if subnet_name else '', ip_list)
        return {'ip_addr' : ip_list}
    #end ip_alloc
    
    @classmethod
    def ip_free(cls, vn_fq_name, subnet_name, ip_list):
        print 'AddrMgmt: release IP %s for vn=%s, subnet=%s' \
            %(ip_list, vn_fq_name, subnet_name if subnet_name else '')
        for ip_addr in ip_list:
            cls.addr_mgmt.ip_free(ip_addr, vn_fq_name, subnet_name)
    #end ip_free

    @classmethod
    def subnet_ip_count(cls, obj_dict, subnet_list):
         ip_count_list = []
         for item in subnet_list:
             ip_count_list.append(cls.addr_mgmt.ip_count(obj_dict, item))
         return {'ip_count_list' : ip_count_list}
    #end ip_count

#end class VirtualNetworkServer
